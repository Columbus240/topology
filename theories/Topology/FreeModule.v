Require Import MathClasses.interfaces.vectorspace.
Require Import MathClasses.interfaces.abstract_algebra.
Require Import MathClasses.theory.groups.
Require Import MathClasses.theory.rings.

Require Import List.
Import ListNotations.

Fixpoint list_equiv {A : Type} `{Equiv A} (l0 l1 : list A) : Prop :=
  match l0, l1 with
  | [], [] => True
  | x0 :: l0, x1 :: l1 =>
    x0 = x1 /\ list_equiv l0 l1
  | _, _ => False
  end.

Instance list_equiv_Setoid {A : Type} (H : Equiv A) (H0 : @Setoid A H) :
  @Setoid (list A) (@list_equiv A H).
Proof.
  repeat split; repeat intro.
  - induction x.
    1: reflexivity.
    split.
    + reflexivity.
    + assumption.
  - generalize dependent y.
    induction x; intros.
    + destruct y.
      * reflexivity.
      * contradiction.
    + destruct y.
      1: contradiction.
      destruct H1.
      split.
      * symmetry. assumption.
      * apply IHx. assumption.
  - generalize dependent z.
    generalize dependent y.
    induction x.
    + destruct y; intros.
      2: contradiction.
      destruct z.
      * reflexivity.
      * contradiction.
    + destruct y; intros.
      1: contradiction.
      destruct z.
      * contradiction.
      * destruct H1, H2.
        split.
        -- transitivity a0; assumption.
        -- apply (IHx y); assumption.
Qed.

Instance fold_left_Proper {A B : Type} `{Equiv A} `{Equiv B}
      (f : A -> B -> A) :
  Proper (equiv ==> equiv ==> equiv) f ->
  Proper (list_equiv ==> equiv ==> equiv) (fold_left f).
Proof.
  repeat split; repeat intro.
  generalize dependent y0.
  generalize dependent x0.
  generalize dependent y.
  induction x; intros.
  { destruct y.
    2: contradiction.
    simpl. assumption.
  }
  destruct y.
  1: contradiction.
  simpl.
  apply IHx.
  - apply H2.
  - apply H1; try assumption.
    apply H2.
Qed.

Lemma fold_left_commonoid {A : Type} `(CommutativeMonoid A) (l : list A) a b :
  (fold_left sg_op l a) & b =
  fold_left sg_op l (a & b).
Proof.
  generalize dependent b.
  generalize dependent a.
  induction l.
  { simpl. reflexivity. }
  simpl.
  intros.
  rewrite IHl.
  apply fold_left_Proper.
  - typeclasses eauto.
  - reflexivity.
  - rewrite <- !associativity.
    rewrite (commutativity a b).
    reflexivity.
Qed.

Corollary fold_left_commonoid_unit {A : Type} `(CommutativeMonoid A) (l : list A) b :
  (fold_left sg_op l mon_unit) & b =
  fold_left sg_op l b.
Proof.
  rewrite fold_left_commonoid.
  2: assumption.
  apply fold_left_Proper.
  - typeclasses eauto.
  - reflexivity.
  - apply left_identity.
Qed.

Instance AbGroup_is_CommutativeMonoid A `(AbGroup A) :
  CommutativeMonoid A.
Proof.
  split; apply H.
Qed.

Section LinearCombinations.
  Context {R M : Type}.
  Context {Re Rplus Rmult Rzero Rone Rnegate}
          {RR : @Ring R Re Rplus Rmult Rzero Rone Rnegate}.
  Context {Me Mop Munit Mnegate Msm}
          `{@Module R M Re Rplus Rmult Rzero Rone Rnegate
             Me Mop Munit Mnegate Msm}.

  Definition linear_combination (l : list (R * M)) : M :=
    fold_left
      (&)
      (map (fun p => (fst p) · (snd p)) l)
      Munit.
End LinearCombinations.

Section ModuleMorphisms.
  Context {R M N : Type}.
  Context {Re Rplus Rmult Rzero Rone Rnegate}
          {RR : @Ring R Re Rplus Rmult Rzero Rone Rnegate}.
  Context {Me Mop Munit Mnegate Msm}
          {Ne Nop Nunit Nnegate Nsm}
          `{@Module R M Re Rplus Rmult Rzero Rone Rnegate
             Me Mop Munit Mnegate Msm}
          `{@Module R N Re Rplus Rmult Rzero Rone Rnegate
             Ne Nop Nunit Nnegate Nsm}.

  Class ModuleMorphism (f : M -> N) :=
    { linearity :
        forall (r0 r1 : R) (m0 m1 : M),
          f ((r0 · m0) & (r1 · m1)) =
          (r0 · (f m0)) & (r1 · (f m1));
    }.

  Lemma ModuleMorphism_linear_combination l f `(ModuleMorphism f) :
    f (linear_combination l) =
    linear_combination
      (map
         (fun p => (fst p, f (snd p)))
         l).
  Proof.
    induction l.
    { simpl.
      admit.
    }
    admit.
  Admitted.
End ModuleMorphisms.

(* The free module over a ring [A] generated by [C].
   But we need a decidable equivalence on [C] for everything to work
   out smoothly. (i.e. classical logic)
 *)
Section FreeModule.
  Variable (R C : Type).
  Context {Re Rplus Rmult Rzero Rone Rnegate}
          {RR : @Ring R Re Rplus Rmult Rzero Rone Rnegate}.
  Context {Cequiv : Equiv C}.
  Context {Cdec : forall x y : C, Decision (x = y)}.

  Definition FreeModule :=
    list (R * C).

  (* Calculate the multiplicity of an element of [C] in an element of
     the [FreeModule]. *)
  Definition FreeModule_mult (l : FreeModule) (c : C) : R :=
    fold_left
      (+)
      (map
         (fun p =>
            if decide (c = snd p) then
              (fst p)
            else
              0)
         l)
      0.

  Global Instance FreeModule_Equiv : Equiv FreeModule :=
    fun l0 l1 =>
      forall c, FreeModule_mult l0 c = FreeModule_mult l1 c.

  Global Instance FreeModule_Op : SgOp FreeModule :=
    fun l0 l1 => l0 ++ l1.

  Lemma FreeModule_Op_mult l0 l1 c :
    FreeModule_mult (l0 & l1) c =
    (FreeModule_mult l0 c) + (FreeModule_mult l1 c).
  Proof.
    unfold sg_op, FreeModule_Op, FreeModule_mult.
    rewrite map_app.
    rewrite fold_left_app.
    rewrite <- fold_left_commonoid_unit.
    2: typeclasses eauto.
    apply commutativity.
  Qed.

  Global Instance FreeModule_Unit : MonUnit FreeModule := [].

  Global Instance FreeModule_Negate : Negate FreeModule :=
    fun l => map (fun p => (- fst p, snd p)) l.

  Lemma FreeModule_Negate_mult l c :
    FreeModule_mult (FreeModule_Negate l) c =
    - FreeModule_mult l c.
  Proof.
    induction l.
    { symmetry.
      apply negate_mon_unit.
    }
    simpl.
    unfold FreeModule_mult in *.
    simpl.
    rewrite !left_identity.
    rewrite <- (fold_left_commonoid_unit _ _ (if decide _ then fst a else 0)).
    rewrite <- (fold_left_commonoid_unit _ _ (if decide _ then - fst a else 0)).
    rewrite IHl.
    rewrite negate_sg_op_distr.
    apply sm_proper.
    destruct (decide (c = snd a)).
    - reflexivity.
    - symmetry.
      apply negate_mon_unit.
  Qed.

  Global Instance FreeModule_ScalarMult : ScalarMult R FreeModule :=
    fun r l => map (fun p => (r * fst p, snd p)) l.

  Lemma FreeModule_ScalarMult_mult a l c :
    FreeModule_mult (FreeModule_ScalarMult a l) c =
    a * (FreeModule_mult l c).
  Proof.
    induction l.
    { simpl.
      symmetry.
      apply right_absorb.
    }
    simpl.
    unfold FreeModule_mult.
    simpl. rewrite !left_identity.
    rewrite <- (fold_left_commonoid_unit _ _ (if decide _ then a * fst a0 else 0)).
    rewrite <- (fold_left_commonoid_unit _ _ (if decide _ then fst a0 else 0)).
    rewrite IHl.
    clear IHl.
    unfold FreeModule_mult.
    rewrite distribute_l.
    apply sm_proper.
    destruct (decide (c = snd a0)).
    - reflexivity.
    - symmetry. apply right_absorb.
  Qed.

  Global Instance FreeModule_Setoid : Setoid FreeModule.
    repeat split; repeat intro.
    - reflexivity.
    - symmetry. apply H.
    - transitivity (FreeModule_mult y c).
      + apply H.
      + apply H0.
  Qed.

  Global Instance FreeModule_module : Module R FreeModule.
  Proof.
    split; try assumption;
      repeat (split; try exact FreeModule_Setoid);
      repeat intro.
    - (* addition is associative *)
      repeat intro.
      rewrite !FreeModule_Op_mult.
      apply associativity.
    - (* addition is proper *)
      repeat intro.
      rewrite !FreeModule_Op_mult.
      rewrite (H c).
      rewrite (H0 c).
      reflexivity.
    - (* the unit behaves as left identity *)
      rewrite !FreeModule_Op_mult.
      apply left_identity.
    - (* the unit behaves as right identity *)
      rewrite !FreeModule_Op_mult.
      apply right_identity.
    - (* negation is proper *)
      rewrite !FreeModule_Negate_mult.
      rewrite (H c).
      reflexivity.
    - (* negation behaves as left inverse *)
      rewrite FreeModule_Op_mult.
      rewrite FreeModule_Negate_mult.
      apply left_inverse.
    - (* negation behaves as right inverse *)
      rewrite FreeModule_Op_mult.
      rewrite FreeModule_Negate_mult.
      apply right_inverse.
    - (* addition is commutative *)
      rewrite !FreeModule_Op_mult.
      apply commutativity.
    - (* scalar multiplication is distributive from the left *)
      rewrite !FreeModule_Op_mult.
      rewrite !FreeModule_ScalarMult_mult.
      rewrite !FreeModule_Op_mult.
      apply distribute_l.
    - (* scalar multiplication is distributive from the right *)
      rewrite !FreeModule_Op_mult.
      rewrite !FreeModule_ScalarMult_mult.
      apply distribute_r.
    - (* scalar multiplication is "associative" *)
      rewrite !FreeModule_ScalarMult_mult.
      apply associativity.
    - (* scalar multiplication respects [1] *)
      rewrite !FreeModule_ScalarMult_mult.
      apply left_identity.
    - (* scalar multiplication is proper *)
      rewrite !FreeModule_ScalarMult_mult.
      rewrite H.
      rewrite (H0 c).
      reflexivity.
  Qed.

  (* TODO: Prove that [C] forms a basis of the [FreeModule]. *)

  (* TODO: Prove that [FreeModule] is determined uniquely up to unique
     isomorphism by the following property. *)
  Definition FreeModule_free_extension {N} `{Module R N} (f : C -> N) :
    FreeModule -> N :=
    fun m =>
      linear_combination (map (fun p => (fst p, f (snd p))) m).

  Instance FreeModule_free_extension_linear {N} `{Module R N} (f : C -> N) :
    ModuleMorphism (FreeModule_free_extension f).
  Proof.
    split. intros.
    unfold FreeModule_free_extension.
    unfold linear_combination.
    admit.
  Admitted.
End FreeModule.
